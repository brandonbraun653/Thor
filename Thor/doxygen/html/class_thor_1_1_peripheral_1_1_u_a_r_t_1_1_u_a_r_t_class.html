<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Thor: Thor::Peripheral::UART::UARTClass Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Thor
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_thor_1_1_peripheral_1_1_u_a_r_t_1_1_u_a_r_t_class.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_thor_1_1_peripheral_1_1_u_a_r_t_1_1_u_a_r_t_class-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Thor::Peripheral::UART::UARTClass Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="uart_8h_source.html">uart.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_thor_1_1_peripheral_1_1_u_a_r_t_1_1_u_a_r_t_class_1_1_u_a_r_t_packet.html">UARTPacket</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a419361d4d6754c1ff6ce1a338a8f4b7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_thor_1_1_definitions_1_1_serial.html#a7d66fc813a50388efcc16107c864f948">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thor_1_1_peripheral_1_1_u_a_r_t_1_1_u_a_r_t_class.html#a419361d4d6754c1ff6ce1a338a8f4b7c">begin</a> (const <a class="el" href="namespace_thor_1_1_definitions_1_1_serial.html#acbcf65573f1e9b38343b93c74df6516e">BaudRate</a> &amp;baud=SERIAL_BAUD_115200, const <a class="el" href="namespace_thor_1_1_definitions_1_1_serial.html#aeb46e286ac4da2f34a54a4081f1539ef">Modes</a> &amp;tx_mode=BLOCKING, const <a class="el" href="namespace_thor_1_1_definitions_1_1_serial.html#aeb46e286ac4da2f34a54a4081f1539ef">Modes</a> &amp;rx_mode=BLOCKING)</td></tr>
<tr class="separator:a419361d4d6754c1ff6ce1a338a8f4b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a38ed548cbd40a25de7fa2df88d0c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_thor_1_1_definitions_1_1_serial.html#a7d66fc813a50388efcc16107c864f948">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thor_1_1_peripheral_1_1_u_a_r_t_1_1_u_a_r_t_class.html#a44a38ed548cbd40a25de7fa2df88d0c0">setMode</a> (const <a class="el" href="namespace_thor_1_1_definitions_1_1_serial.html#a1a3716aad8b1534002639eaec645a2e7">SubPeripheral</a> &amp;periph, const <a class="el" href="namespace_thor_1_1_definitions_1_1_serial.html#aeb46e286ac4da2f34a54a4081f1539ef">Modes</a> &amp;mode)</td></tr>
<tr class="separator:a44a38ed548cbd40a25de7fa2df88d0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da8c2ffe2767d398fc93c564003d193"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_thor_1_1_definitions_1_1_serial.html#a7d66fc813a50388efcc16107c864f948">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thor_1_1_peripheral_1_1_u_a_r_t_1_1_u_a_r_t_class.html#a0da8c2ffe2767d398fc93c564003d193">write</a> (uint8_t *val, size_t length)</td></tr>
<tr class="separator:a0da8c2ffe2767d398fc93c564003d193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc76965a863b1bd9b0dbcf23e7ed202"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_thor_1_1_definitions_1_1_serial.html#a7d66fc813a50388efcc16107c864f948">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thor_1_1_peripheral_1_1_u_a_r_t_1_1_u_a_r_t_class.html#a0dc76965a863b1bd9b0dbcf23e7ed202">write</a> (char *string, size_t length)</td></tr>
<tr class="separator:a0dc76965a863b1bd9b0dbcf23e7ed202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9be3fb22d7f85e61bbac7b9a142d1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_thor_1_1_definitions_1_1_serial.html#a7d66fc813a50388efcc16107c864f948">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thor_1_1_peripheral_1_1_u_a_r_t_1_1_u_a_r_t_class.html#abf9be3fb22d7f85e61bbac7b9a142d1b">write</a> (const char *string)</td></tr>
<tr class="separator:abf9be3fb22d7f85e61bbac7b9a142d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1875018812bc8836ff9371292fc6585d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_thor_1_1_definitions_1_1_serial.html#a7d66fc813a50388efcc16107c864f948">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thor_1_1_peripheral_1_1_u_a_r_t_1_1_u_a_r_t_class.html#a1875018812bc8836ff9371292fc6585d">write</a> (const char *string, size_t length)</td></tr>
<tr class="separator:a1875018812bc8836ff9371292fc6585d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbad408f9f76ebc4eb6285021bdcbcda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_thor_1_1_definitions_1_1_serial.html#a7d66fc813a50388efcc16107c864f948">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thor_1_1_peripheral_1_1_u_a_r_t_1_1_u_a_r_t_class.html#abbad408f9f76ebc4eb6285021bdcbcda">readSync</a> (uint8_t *buff, size_t length)</td></tr>
<tr class="separator:abbad408f9f76ebc4eb6285021bdcbcda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b5e3ba6a190c915a05b0f7790e67b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_thor_1_1_definitions_1_1_serial.html#a7d66fc813a50388efcc16107c864f948">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thor_1_1_peripheral_1_1_u_a_r_t_1_1_u_a_r_t_class.html#af3b5e3ba6a190c915a05b0f7790e67b5">readPacket</a> (uint8_t *buff, size_t buff_length)</td></tr>
<tr class="separator:af3b5e3ba6a190c915a05b0f7790e67b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb29e7e2f1004a0e8ff8f0dafa5053b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thor_1_1_peripheral_1_1_u_a_r_t_1_1_u_a_r_t_class.html#aebb29e7e2f1004a0e8ff8f0dafa5053b">availablePackets</a> ()</td></tr>
<tr class="separator:aebb29e7e2f1004a0e8ff8f0dafa5053b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0131795a9d05984d1673a9140a65403d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thor_1_1_peripheral_1_1_u_a_r_t_1_1_u_a_r_t_class.html#a0131795a9d05984d1673a9140a65403d">nextPacketSize</a> ()</td></tr>
<tr class="separator:a0131795a9d05984d1673a9140a65403d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b01199cca2948dbdbdc8c1fb4f02d21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thor_1_1_peripheral_1_1_u_a_r_t_1_1_u_a_r_t_class.html#a1b01199cca2948dbdbdc8c1fb4f02d21">end</a> ()</td></tr>
<tr class="separator:a1b01199cca2948dbdbdc8c1fb4f02d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9038df0656f11d307889e148f45890d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thor_1_1_peripheral_1_1_u_a_r_t_1_1_u_a_r_t_class.html#a9038df0656f11d307889e148f45890d5">attachSettings</a> (UART_InitTypeDef config)</td></tr>
<tr class="separator:a9038df0656f11d307889e148f45890d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea0ce3d2908c1cf0927ebd418834a39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thor_1_1_peripheral_1_1_u_a_r_t_1_1_u_a_r_t_class.html#a1ea0ce3d2908c1cf0927ebd418834a39">IRQHandler</a> ()</td></tr>
<tr class="separator:a1ea0ce3d2908c1cf0927ebd418834a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8702f75ba28ab2a244904e6b5730250e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thor_1_1_peripheral_1_1_u_a_r_t_1_1_u_a_r_t_class.html#a8702f75ba28ab2a244904e6b5730250e">IRQHandler_TXDMA</a> ()</td></tr>
<tr class="separator:a8702f75ba28ab2a244904e6b5730250e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135048b23f4dc5d40d7f8faf14401a15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thor_1_1_peripheral_1_1_u_a_r_t_1_1_u_a_r_t_class.html#a135048b23f4dc5d40d7f8faf14401a15">IRQHandler_RXDMA</a> ()</td></tr>
<tr class="separator:a135048b23f4dc5d40d7f8faf14401a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae2e48787f8e3c2fdec0d3d075ee05b05"><td class="memItemLeft" align="right" valign="top">static boost::shared_ptr&lt; <a class="el" href="class_thor_1_1_peripheral_1_1_u_a_r_t_1_1_u_a_r_t_class.html">UARTClass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_thor_1_1_peripheral_1_1_u_a_r_t_1_1_u_a_r_t_class.html#ae2e48787f8e3c2fdec0d3d075ee05b05">create</a> (const int channel)</td></tr>
<tr class="separator:ae2e48787f8e3c2fdec0d3d075ee05b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A higher level uart interface built ontop of the STM32 HAL that abstracts away most of the details associated with setup and general usage. It supports both transmission<br />
and reception in 3 modes [blocking, interrupt, dma] and does not require that TX and RX share the same mode for proper operation. In addition, data is copied to an internal buffer<br />
for all non-blocking transmissions (IT/DMA) so that the user doesn't have to worry about destroyed or mutable data.</p>
<dl class="section note"><dt>Note</dt><dd>If using FreeRTOS, the class is threadsafe and allows multiple sources to write and read on a class object up to an internal buffer limit defined by Thor::Definitions::Serial::UART_BUFFER_SIZE </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a9038df0656f11d307889e148f45890d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9038df0656f11d307889e148f45890d5">&#9670;&nbsp;</a></span>attachSettings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Thor::Peripheral::UART::UARTClass::attachSettings </td>
          <td>(</td>
          <td class="paramtype">UART_InitTypeDef&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides a convenient way for the user to specifiy advanced configuration settings. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Configuration settings customized from the STM32 <a class="el" href="namespace_thor_1_1_peripheral_1_1_u_a_r_t.html">UART</a> HAL struct defintion </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebb29e7e2f1004a0e8ff8f0dafa5053b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb29e7e2f1004a0e8ff8f0dafa5053b">&#9670;&nbsp;</a></span>availablePackets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Thor::Peripheral::UART::UARTClass::availablePackets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>How many unread asynchronously received packets are available </p><dl class="section return"><dt>Returns</dt><dd>number of available packets </dd></dl>

</div>
</div>
<a id="a419361d4d6754c1ff6ce1a338a8f4b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419361d4d6754c1ff6ce1a338a8f4b7c">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_thor_1_1_definitions_1_1_serial.html#a7d66fc813a50388efcc16107c864f948">Status</a> Thor::Peripheral::UART::UARTClass::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_thor_1_1_definitions_1_1_serial.html#acbcf65573f1e9b38343b93c74df6516e">BaudRate</a> &amp;&#160;</td>
          <td class="paramname"><em>baud</em> = <code>SERIAL_BAUD_115200</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_thor_1_1_definitions_1_1_serial.html#aeb46e286ac4da2f34a54a4081f1539ef">Modes</a> &amp;&#160;</td>
          <td class="paramname"><em>tx_mode</em> = <code>BLOCKING</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_thor_1_1_definitions_1_1_serial.html#aeb46e286ac4da2f34a54a4081f1539ef">Modes</a> &amp;&#160;</td>
          <td class="paramname"><em>rx_mode</em> = <code>BLOCKING</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes with a given baud rate and TX/RX modes. If no parameters are given it will default to a baudrate of 115200 and set both TX and RX modes to blocking.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baud</td><td>Desired baud rate. Accepts standard rates from <a class="el" href="namespace_thor_1_1_definitions_1_1_serial.html#acbcf65573f1e9b38343b93c74df6516e">Thor::Definitions::Serial::BaudRate</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tx_mode</td><td>Sets the TX mode to Blocking, Interrupt, or DMA from <a class="el" href="namespace_thor_1_1_definitions_1_1_serial.html#aeb46e286ac4da2f34a54a4081f1539ef">Thor::Definitions::Serial::Modes</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rx_mode</td><td>Sets the RX mode to Blocking, Interrupt, or DMA from <a class="el" href="namespace_thor_1_1_definitions_1_1_serial.html#aeb46e286ac4da2f34a54a4081f1539ef">Thor::Definitions::Serial::Modes</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code indicating peripheral state. Will read 'PERIPH_OK' if everything is fine. Otherwise it will return a code from Thor::Peripheral::Serial::Status </dd></dl>

</div>
</div>
<a id="ae2e48787f8e3c2fdec0d3d075ee05b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e48787f8e3c2fdec0d3d075ee05b05">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static boost::shared_ptr&lt;<a class="el" href="class_thor_1_1_peripheral_1_1_u_a_r_t_1_1_u_a_r_t_class.html">UARTClass</a>&gt; Thor::Peripheral::UART::UARTClass::create </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A factory method to create a new <a class="el" href="class_thor_1_1_peripheral_1_1_u_a_r_t_1_1_u_a_r_t_class.html">UARTClass</a> object.</p>
<p>This method intentionally replaces the typical constructor due to the need to register the shared_ptr with a static_vector that allows runtime deduction of which class to call inside of an ISR. This is done for simplicity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channel</td><td>Hardware peripheral channel number (i.e. 1 for UART1, 4 for UART4, etc) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared pointer to the new object </dd></dl>

</div>
</div>
<a id="a1b01199cca2948dbdbdc8c1fb4f02d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b01199cca2948dbdbdc8c1fb4f02d21">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Thor::Peripheral::UART::UARTClass::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deinitializes and cleans up the peripheral </p>

</div>
</div>
<a id="a1ea0ce3d2908c1cf0927ebd418834a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ea0ce3d2908c1cf0927ebd418834a39">&#9670;&nbsp;</a></span>IRQHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Thor::Peripheral::UART::UARTClass::IRQHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Primary handler for interrupt mode in TX or RX. Additionally, will be called in DMA mode after <a class="el" href="class_thor_1_1_peripheral_1_1_u_a_r_t_1_1_u_a_r_t_class.html#a8702f75ba28ab2a244904e6b5730250e">UARTClass::IRQHandler_TXDMA</a> or <a class="el" href="class_thor_1_1_peripheral_1_1_u_a_r_t_1_1_u_a_r_t_class.html#a135048b23f4dc5d40d7f8faf14401a15">UARTClass::IRQHandler_RXDMA</a> </p>

</div>
</div>
<a id="a135048b23f4dc5d40d7f8faf14401a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135048b23f4dc5d40d7f8faf14401a15">&#9670;&nbsp;</a></span>IRQHandler_RXDMA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Thor::Peripheral::UART::UARTClass::IRQHandler_RXDMA </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DMA Handler for RX. It is a simple wrapper that calls the correct STM32 HAL DMA Handler. </p>

</div>
</div>
<a id="a8702f75ba28ab2a244904e6b5730250e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8702f75ba28ab2a244904e6b5730250e">&#9670;&nbsp;</a></span>IRQHandler_TXDMA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Thor::Peripheral::UART::UARTClass::IRQHandler_TXDMA </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DMA Handler for TX. It is a simple wrapper that calls the correct STM32 HAL DMA Handler. </p>

</div>
</div>
<a id="a0131795a9d05984d1673a9140a65403d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0131795a9d05984d1673a9140a65403d">&#9670;&nbsp;</a></span>nextPacketSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Thor::Peripheral::UART::UARTClass::nextPacketSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the size of the next asynchronously received packet in the buffer </p><dl class="section return"><dt>Returns</dt><dd>next packet size </dd></dl>

</div>
</div>
<a id="af3b5e3ba6a190c915a05b0f7790e67b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3b5e3ba6a190c915a05b0f7790e67b5">&#9670;&nbsp;</a></span>readPacket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_thor_1_1_definitions_1_1_serial.html#a7d66fc813a50388efcc16107c864f948">Status</a> Thor::Peripheral::UART::UARTClass::readPacket </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buff_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the next packet received into a buffer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buff</td><td>Address of an external buffer to read data into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buff_length</td><td>The size of the external buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code indicating peripheral state. Will read 'UART_OK' if everything is fine. Otherwise it will return a code from Thor::Peripheral::UART::UART_Status</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This grabs data from an asynchronous data reception of unknown length in Interrupt or DMA mode only. If the length is known and only one transmission is to be received, use the provided readSync function instead. </dd></dl>

</div>
</div>
<a id="abbad408f9f76ebc4eb6285021bdcbcda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbad408f9f76ebc4eb6285021bdcbcda">&#9670;&nbsp;</a></span>readSync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_thor_1_1_definitions_1_1_serial.html#a7d66fc813a50388efcc16107c864f948">Status</a> Thor::Peripheral::UART::UARTClass::readSync </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Commands the RX peripheral to read a single transmission of known length into the provided buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buff</td><td>An external buffer to write the received data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The number of bytes to be received</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Only use this for receptions that have a fixed, known length. For transmissions that last longer than the given 'length' value, it will simply be ignored and lost forever. Poor data. </dd></dl>

</div>
</div>
<a id="a44a38ed548cbd40a25de7fa2df88d0c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44a38ed548cbd40a25de7fa2df88d0c0">&#9670;&nbsp;</a></span>setMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_thor_1_1_definitions_1_1_serial.html#a7d66fc813a50388efcc16107c864f948">Status</a> Thor::Peripheral::UART::UARTClass::setMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_thor_1_1_definitions_1_1_serial.html#a1a3716aad8b1534002639eaec645a2e7">SubPeripheral</a> &amp;&#160;</td>
          <td class="paramname"><em>periph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_thor_1_1_definitions_1_1_serial.html#aeb46e286ac4da2f34a54a4081f1539ef">Modes</a> &amp;&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Places the specified peripheral into a given mode </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">periph</td><td>Explicitly states which peripheral subsystem (TX or RX) to set from Thor::Peripheral::Serial::SubPeripheral </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>The corresponding mode for the peripheral to enter, from Thor::Peripheral::Serial::Modes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code indicating peripheral state. Will read 'PERIPH_OK' if everything is fine. Otherwise it will return a code from Thor::Peripheral::Serial::Status</dd></dl>
<dl class="section note"><dt>Note</dt><dd>When setting the RX peripheral to IT or DMA mode, it automatically enables asynchronous data reception </dd></dl>

</div>
</div>
<a id="a0da8c2ffe2767d398fc93c564003d193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da8c2ffe2767d398fc93c564003d193">&#9670;&nbsp;</a></span>write() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_thor_1_1_definitions_1_1_serial.html#a7d66fc813a50388efcc16107c864f948">Status</a> Thor::Peripheral::UART::UARTClass::write </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes data to the serial output </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Pointer to a mutable array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The length of data to be sent out </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code indicating peripheral state. Will read 'PERIPH_OK' if everything is fine. Otherwise it will return a code from Thor::Peripheral::Serial::Status </dd></dl>

</div>
</div>
<a id="a0dc76965a863b1bd9b0dbcf23e7ed202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc76965a863b1bd9b0dbcf23e7ed202">&#9670;&nbsp;</a></span>write() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_thor_1_1_definitions_1_1_serial.html#a7d66fc813a50388efcc16107c864f948">Status</a> Thor::Peripheral::UART::UARTClass::write </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes data to the serial output </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>Pointer to a mutable character array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The length of data to be sent out </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code indicating peripheral state. Will read 'PERIPH_OK' if everything is fine. Otherwise it will return a code from Thor::Peripheral::Serial::Status </dd></dl>

</div>
</div>
<a id="abf9be3fb22d7f85e61bbac7b9a142d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf9be3fb22d7f85e61bbac7b9a142d1b">&#9670;&nbsp;</a></span>write() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_thor_1_1_definitions_1_1_serial.html#a7d66fc813a50388efcc16107c864f948">Status</a> Thor::Peripheral::UART::UARTClass::write </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes data to the serial output </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>Pointer to an immutable character array. The length is internally calculated with strlen() </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code indicating peripheral state. Will read 'PERIPH_OK' if everything is fine. Otherwise it will return a code from Thor::Peripheral::Serial::Status </dd></dl>

</div>
</div>
<a id="a1875018812bc8836ff9371292fc6585d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1875018812bc8836ff9371292fc6585d">&#9670;&nbsp;</a></span>write() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_thor_1_1_definitions_1_1_serial.html#a7d66fc813a50388efcc16107c864f948">Status</a> Thor::Peripheral::UART::UARTClass::write </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes data to the serial output </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>Pointer to an immutable character array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The length of data to be sent out </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status code indicating peripheral state. Will read 'PERIPH_OK' if everything is fine. Otherwise it will return a code from Thor::Peripheral::Serial::Status </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>G:/git/Microcontrollers/Thor_STM32/Thor/include/<a class="el" href="uart_8h_source.html">uart.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_thor.html">Thor</a></li><li class="navelem"><a class="el" href="namespace_thor_1_1_peripheral.html">Peripheral</a></li><li class="navelem"><a class="el" href="namespace_thor_1_1_peripheral_1_1_u_a_r_t.html">UART</a></li><li class="navelem"><a class="el" href="class_thor_1_1_peripheral_1_1_u_a_r_t_1_1_u_a_r_t_class.html">UARTClass</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
