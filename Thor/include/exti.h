#pragma once
#ifndef EXTI_H_
#define EXTI_H_

/* Boost Includes */
#include <boost/circular_buffer.hpp>
#include <boost/container/vector.hpp>
#include <boost/shared_ptr.hpp>
#include <boost/make_shared.hpp>

/* Thor Includes */
#include <Thor/include/config.h>
#include <Thor/include/definitions.h>
#include <Thor/include/interrupt.h>

/* Additional includes not provided in Thor config */
#if defined(TARGET_STM32F4)
#include "stm32f4xx_ll_exti.h"

#elif defined(TARGET_STM32F7)
#include "stm32f7xx_ll_exti.h"
#endif

#if defined(USING_FREERTOS)
#include "FreeRTOS.h"
#include "semphr.h"

/** Ensures that the EXTI0 interrupt will always be able to preempt most other 
 *	threads running on the kernel. This is important for quick response times. 
 **/
#define EXTI0_IRQn_Priority (configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY)

/** Properly sets up the EXTI0_Interrupt */
extern void setupEXTI0_Interrupt();

using namespace Thor::Definitions::Interrupt;


class TaskTrigger;
extern boost::circular_buffer<TaskTrigger*> TriggerBuffer;

/** Implements a convenient way to trigger a FreeRTOS task upon an event generated by another peripheral. */
class TaskTrigger
{
public:
	/** Informs TaskTrigger that an event has occured. Typically this is called from an ISR routine. 
	 *	@param[in] source	The source peripheral from which the event was generated 
	 *	@param[in] instance	The peripheral instance (i.e. 1, 2, 3, etc)
	 **/
	void logEvent(Trigger trig, TaskTrigger* objAddr)
	{
		pendingTask.push_back(trig);		//This logs which trigger generated the request
		TriggerBuffer.push_back(objAddr);	//This lets the ISR know what class object to use
		
		/* Trigger the EXTI0 Interrupt to signal data ready. Because it has a lower priority
		 * than whatever ISR is calling, it will not immediately fire. */
		LL_EXTI_GenerateSWI_0_31(LL_EXTI_LINE_0);
	}
	
	/** Ataches a semaphore to an interrupt source. When the source is triggered, it will automatically
	 *	'give' to that semaphore.
	 *
	 *	@param[in] source	The source peripheral to trigger from
	 *	@param[in] instance	The peripheral instance (i.e. 1, 2, 3, etc)
	 *	@param[in] semphr	Address of the semaphore object to be triggered
	 **/
	void attachEventConsumer(Trigger trig, SemaphoreHandle_t* semphr)
	{
		semaphores[trig] = semphr;
	}
	
	void removeEventConsumer(Trigger trig)
	{
		semaphores[trig] = nullptr;
	}
	
	/** An ISR only function that returns the next semaphore to be triggered
	 *	@return semaphore address 
	 **/
	SemaphoreHandle_t* getEventSemaphore()
	{
		SemaphoreHandle_t* tempSem = nullptr;

		if (!pendingTask.empty())
		{
			tempSem = semaphores[pendingTask.front()];
			pendingTask.pop_front();
		}
		
		return tempSem;
	}

	TaskTrigger()
	{
		pendingTask.set_capacity(MAX_PENDING_TASK_TRIGGERS);
	}
	
	~TaskTrigger() = default;
	
private:
	boost::circular_buffer<Trigger> pendingTask;
	SemaphoreHandle_t* semaphores[Trigger::MAX_SOURCES];
};




#endif /* USING_FREERTOS */


#ifdef __cplusplus
extern "C" {
#endif
	void EXTI0_IRQHandler();
	void EXTI1_IRQHandler();
	void EXTI2_IRQHandler();
	void EXTI3_IRQHandler();
	void EXTI4_IRQHandler();
	void EXTI9_5_IRQHandler();
	void EXTI15_10_IRQHandler();
#ifdef __cplusplus
}
#endif

#endif